//@author: a0115777w



	/**
	 * origin: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\command\Command.java
	 */

	public Command(CommandType type, boolean undoable) {
		this.type = type;
		this.undoable = undoable;
	}
	
	public CommandType getCommandType() {
		return this.type;
	}
	
	protected void setCommandType(CommandType type){
		this.type = type;
	}

	public int getId() {
		return this.id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public abstract void execute() throws Exception;

	public abstract void undo() throws Exception;
	
	public abstract String getCommandContent();

	public boolean isUndoable() {
		return undoable;
	}

	public void setUndoable(boolean undoable) {
		this.undoable = undoable;
	}
}

	// End of segment: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\command\Command.java





	/**
	 * origin: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\command\CommandAdd.java
	 */

	public CommandAdd(Done task) {
		super(CommandType.ADD, true);
		this.task = task;
		
		if(task.getType().equals(TaskType.TIMED)){
			this.reminderTask = new TaskReminder((DoneTimedTask) task);
		}
		
		commandLogger.log(Level.INFO, "Add Command Created");
	}

	public Done getTask() {
		return this.task;
	}

	public void setTask(Done task) {
		this.task = task;
	}

	// End of segment: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\command\CommandAdd.java





	/**
	 * origin: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\command\CommandClear.java
	 */

	public CommandClear(){
		super(CommandType.CLEAR, false);
		commandLogger.log(Level.INFO, "Clear Command Created");
	}

	// End of segment: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\command\CommandClear.java





	/**
	 * origin: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\command\CommandClearDone.java
	 */

	public CommandClearDone(){
		super(CommandType.CLEARDONE,false);
		commandLogger.log(Level.INFO, "ClearDone Command Created");
	}

	@Override
	public void execute() throws Exception {
		commandLogger.log(Level.INFO, "Cleardone Command Execution called");
		InMemStorage.getInstance().clearDoneTasks();
		commandLogger.log(Level.INFO, "cleardone Command Execution succeeded");
	}

	//undo not required in CLEARDONE
	@Override
	public void undo() throws Exception {
		// TODO Auto-generated method stub

	}
	
	// End of segment: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\command\CommandClearDone.java





	/**
	 * origin: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\command\CommandDelete.java
	 */

	public CommandDelete(int deleteIndex) throws Exception {
		super(CommandType.DELETE, true);
		assert deleteIndex > 0;
		if (deleteIndex > InMemStorage.getInstance().getTasks().size()) {
			throw new Exception("Too large Destination Index Value");
		}
		this.deleteIndex = deleteIndex;
		commandLogger.log(Level.INFO, "Delete Command Created");
	}

	public CommandDelete(Done task) {
		super(CommandType.DELETE, true);
		this.task = task;
		commandLogger.log(Level.INFO, "Delete Command Created");
	}

	// End of segment: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\command\CommandDelete.java





	/**
	 * origin: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\command\CommandDone.java
	 */

	public CommandDone(int doneIndex) throws Exception {
		super(CommandType.DONE, true);
		assert doneIndex > 0;
		if (doneIndex > InMemStorage.getInstance().getTasks().size()) {
			throw new Exception("Too large Destination Index Value");
		}
		this.task = InMemStorage.getInstance().getTask(doneIndex);
		commandLogger.log(Level.INFO, "Done Command Created");
	}
	
	public CommandDone(Done task) {
		super(CommandType.DONE, true);
		this.task = task;
		commandLogger.log(Level.INFO, "Done Command Created");
	}
	
	@Override
	public void execute() throws Exception {
		InMemStorage inMemStorage = InMemStorage.getInstance();
		inMemStorage.setCompleted(task);
	}

	@Override
	public void undo() {
		InMemStorage inMemStorage = InMemStorage.getInstance();
		inMemStorage.setIncomplete(task);
	}
	
	// End of segment: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\command\CommandDone.java





	/**
	 * origin: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\command\CommandEdit.java
	 */

	public CommandEdit(int editIndex, Done task) throws Exception {
		super(CommandType.EDIT, true);
		assert editIndex > 0;
		if (editIndex > InMemStorage.getInstance().getTasks().size()) {
			throw new Exception("Too large Destination Index Value");
		}
		this.editIndex = editIndex;
		this.task = task;
		commandLogger.log(Level.INFO, "Edit Command Created");
	}

	@Override
	// This method edits First tasks with the same Title
	public void execute() throws Exception {
		commandLogger.log(Level.INFO, "Edit Command called");
		InMemStorage memory = InMemStorage.getInstance();
		this.subbedTask = memory.getTask(editIndex);
		memory.edit(task, editIndex - 1);
		commandLogger.log(Level.INFO, "Edit Command successfully executed");
	}

	@Override
	public void undo() {
		commandLogger.log(Level.INFO, "Undo Command called");
		InMemStorage memory = InMemStorage.getInstance();
		memory.edit(subbedTask, editIndex - 1);
		commandLogger.log(Level.INFO, "Undo Command successfully executed");
	}

	// End of segment: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\command\CommandEdit.java





	/**
	 * origin: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\command\CommandExit.java
	 */

	public CommandExit(boolean isNormal){
		super(CommandType.EXIT,false);
		this.isNormal = isNormal;
		commandLogger.log(Level.INFO, "Exit Command Created");
	}

	@Override
	public void execute() throws Exception {
		if(isNormal){
			System.exit(STATUS_NORMAL);
		}
		System.exit(STATUS_ABNORMAL);
	}

	@Override
	public void undo() {
		//not implemented
	}
	
	// End of segment: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\command\CommandExit.java





	/**
	 * origin: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\command\CommandInvalid.java
	 */

	public CommandInvalid(){
		super(CommandType.INVALID, false);
		commandLogger.log(Level.INFO, "Invalid Command Created");

	}

	@Override
	public void execute() {
		// TODO Auto-generated method stub

	}

	@Override
	public void undo() {
		// TODO Auto-generated method stub

	}
	
	// End of segment: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\command\CommandInvalid.java





	/**
	 * origin: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\command\CommandLoad.java
	 */

	public CommandLoad(String jsonName) {
		super(CommandType.LOAD, false);
		this.jsonName = jsonName;
		commandLogger.log(Level.INFO, "Load Command Created");
	}

	// End of segment: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\command\CommandLoad.java





	/**
	 * origin: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\command\CommandMove.java
	 */

	public CommandMove(int origin, int destination) throws Exception {
		super(CommandType.MOVE, true);
		if (origin > (InMemStorage.getInstance().getTasks().size())
				|| destination > (InMemStorage.getInstance().getTasks().size())) {
			throw new Exception("Too large Destination Index Value");
		}
		this.origin = origin - 1;
		this.destination = destination - 1;
		commandLogger.log(Level.INFO, "Move Command Created");
	}

	@Override
	public void execute() throws Exception {
		commandLogger.log(Level.INFO, "Move Command Execution called");
		InMemStorage memory = InMemStorage.getInstance();
		// List<Done> tasks = memory.getTasks();
		// swap(tasks, origin, destination);
		memory.move(origin, destination);
		commandLogger.log(Level.INFO, "Move Command Execution Successful");
	}

	@Override
	public void undo() throws Exception {
		InMemStorage memory = InMemStorage.getInstance();
		// List<Done> tasks = memory.getTasks();
		// swap(tasks, destination, origin);
		memory.move(destination, origin);
	}

	// End of segment: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\command\CommandMove.java





	/**
	 * origin: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\command\CommandRecur.java
	 */


	public CommandRecur(int recurIndex, String period) throws Exception{
		super(CommandType.RECUR, true);
		if (recurIndex > InMemStorage.getInstance().getTasks().size()) {
			commandLogger.log(Level.INFO, "Too large Index");
			throw new Exception("Too large Destination Index Value");
		}
		this.task = InMemStorage.getInstance().getTask(recurIndex);
		this.frequency = period;
		commandLogger.log(Level.INFO, "Recur Command Created");
	}

	public CommandRecur(Done task,String period){
		super(CommandType.RECUR,true);
		this.task = task;
		this.frequency = period;
		commandLogger.log(Level.INFO, "Recur Command Created");
	}
	
	// End of segment: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\command\CommandRecur.java





	/**
	 * origin: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\command\CommandRemind.java
	 */

	public CommandRemind(int remindIndex, String date, String time) throws Exception {
		super(CommandType.REMIND, true);
		if (remindIndex > InMemStorage.getInstance().getTasks().size()) {
			throw new Exception("Too large Destination Index Value");
		}
		this.task = InMemStorage.getInstance().getTask(remindIndex);
		this.remindIndex = remindIndex;
		this.date = date;
		this.time = time;
		commandLogger.log(Level.INFO, "Remind Command Created");
	}

	@Override
	public void execute() throws Exception {
		commandLogger.log(Level.INFO, "Remind Command called");
		this.reminderTask = new TaskReminder(task, date, time);
		commandLogger.log(Level.INFO, "Remind Command successfully executed");
	}

	@Override
	public void undo() {
		//Currently not undoable
		//commandLogger.log(Level.INFO, "undo Remind Command called");
		//commandLogger.log(Level.INFO, "undo Remind Command successfully executed");
		reminderTask.stopTimer();
	}
	
	// End of segment: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\command\CommandRemind.java





	/**
	 * origin: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\command\CommandSearch.java
	 */

	public CommandSearch(String searchString) {
		super(CommandType.SEARCH, false);
		this.searchString = searchString;
		commandLogger.log(Level.INFO, "Search Command Created");
	}

	public String getSearchString() {
		return this.searchString;
	}

	public void setSearchString(String searchstring) {
		this.searchString = searchstring;
	}

	// End of segment: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\command\CommandSearch.java





	/**
	 * origin: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\command\CommandShowAll.java
	 */

	public CommandShowAll() {
		super(CommandType.SHOWALL, false);
	}

	@Override
	public void execute() {
		commandLogger.log(Level.INFO, "Showall Command called");
		InMemStorage memory = InMemStorage.getInstance();
		List<Done> tasks = memory.getTasks();
		memory.emptyWorkingTasks();

		for (int i = 0; i < tasks.size(); i++) {
			memory.addIntoWorkingTask(tasks.get(i));
		}
		commandLogger.log(Level.INFO, "Showall Command successful");
	}

	@Override
	public void undo() {
		//NOT IMPLEMENTED
	}
	
	// End of segment: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\command\CommandShowAll.java





	/**
	 * origin: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\command\CommandUndo.java
	 */

	public CommandUndo() {
		super(CommandType.UNDO, false);
		commandLogger.log(Level.INFO, "Undo Command Created");
	}
	
	// End of segment: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\command\CommandUndo.java





	/**
	 * origin: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\parser\CommandParser.java
	 */

	private CommandParser() {

	}

	public static CommandParser getInstance() {
		if (instance == null) {
			instance = new CommandParser();
		}
		return instance;
	}

	public Command parseInputToMakeCommand(String userCommand) {

		parserLogger.log(Level.INFO, "Input passed to make Command");
		String commandWord = ParserUtility.getFirstWord(userCommand);
		String commandContent = ParserUtility.removeFirstWord(userCommand);
		return makeCommand(commandWord, commandContent);

	}
	
	// End of segment: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\parser\CommandParser.java





	/**
	 * origin: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\parser\CommandParser.java
	 */

	private Command makeCommand(String commandWord, String commandContent) {
		if (commandWord.equalsIgnoreCase("add")) {
			parserLogger.log(Level.INFO, "make add Command");
			return ParserUtility.makeAdd(commandContent);
		} else if (commandWord.equalsIgnoreCase("delete")) {
			parserLogger.log(Level.INFO, "make delete Command");
			return ParserUtility.makeDelete(commandContent);
		} else if (commandWord.equalsIgnoreCase("edit")) {
			return ParserUtility.makeEdit(commandContent);
		} else if (commandWord.equalsIgnoreCase("clear")) {
			return ParserUtility.makeClear(commandContent);
		} else if (commandWord.equalsIgnoreCase("move")) {
			return ParserUtility.makeMove(commandContent);
		} else if (commandWord.equalsIgnoreCase("search")) {
			return ParserUtility.makeSearch(commandContent);
		} else if (commandWord.equalsIgnoreCase("showall")) {
			return ParserUtility.makeShowAll();
		} else if (commandWord.equalsIgnoreCase("done")) {
			return ParserUtility.makeDone(commandContent);
		} else if (commandWord.equalsIgnoreCase("cleardone")) {
			return ParserUtility.makeClearDone();
		} else if (commandWord.equalsIgnoreCase("recur")) {
			return ParserUtility.makeRecur(commandContent);
		} else if (commandWord.equalsIgnoreCase("remind")) {
			return ParserUtility.makeRemind(commandContent);
		} else if (commandWord.equalsIgnoreCase("load")) {
			return ParserUtility.makeLoad(commandContent);
		} else if (commandWord.equalsIgnoreCase("undo")) {
			return ParserUtility.makeUndo();
		} else if (commandWord.equalsIgnoreCase("exit")) {
			return ParserUtility.makeExit();
		} else {
			return ParserUtility.makeInvalid();
		}
	}

	public CommandType getCommandType(String userCommand) {

		String command = ParserUtility.getFirstWord(userCommand);

		if (command.equalsIgnoreCase("add")) {
			return CommandType.ADD;
		} else if (command.equalsIgnoreCase("delete")) {
			return CommandType.DELETE;
		} else if (command.equalsIgnoreCase("clear")) {
			return CommandType.CLEAR;
		} else if (command.equalsIgnoreCase("edit")) {
			return CommandType.EDIT;
		} else if (command.equalsIgnoreCase("load")) {
			return CommandType.LOAD;
		} else if (command.equalsIgnoreCase("search")) {
			return CommandType.SEARCH;
		} else if (command.equalsIgnoreCase("showall")) {
			return CommandType.SHOWALL;
		} else if (command.equalsIgnoreCase("undo")) {
			return CommandType.UNDO;
		} else if (command.equalsIgnoreCase("move")) {
			return CommandType.MOVE;
		} else if (command.equalsIgnoreCase("done")) {
			return CommandType.DONE;
		} else if (command.equalsIgnoreCase("cleardone")) {
			return CommandType.CLEARDONE;
		} else if (command.equalsIgnoreCase("remind")) {
			return CommandType.REMIND;
		} else if (command.equalsIgnoreCase("recur")) {
			return CommandType.RECUR;
		} else if (command.equalsIgnoreCase("exit")) {
			return CommandType.EXIT;
		} else {
			return CommandType.INVALID;
		}
	}

	public String getCommandContent(String userCommand) {
		String currentContent = ParserUtility.removeFirstWord(userCommand);
		return currentContent;
	}
	
}

	// End of segment: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\parser\CommandParser.java





	/**
	 * origin: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\parser\ParserUtility.java
	 */

	protected static Command makeAdd(String content){
		try{
			Done tempTask = defineTask(content);
			return new CommandAdd(tempTask);
		}catch (Exception e){
			return new CommandInvalid();
		}
	}
	
	protected static Command makeDelete(String content){
		if (isPositiveInt(content)) {
			try{
				return new CommandDelete(Integer.parseInt(content));
			}catch(Exception e){
				return new CommandInvalid();
			}
		} else {
			return new CommandInvalid();
		}
	}

	protected static Command makeEdit(String content){
		String indexString = getFirstWord(content);
		if (isPositiveInt(indexString)) {
			try{
				int index = Integer.parseInt(indexString);
				Done changedTask = defineTask(removeFirstWord(content));
				parserLogger.log(Level.INFO, "make edit Command");
				return new CommandEdit(index, changedTask);
			}catch (Exception e){
				parserLogger.log(Level.INFO, "make invalid Command instead");
				return new CommandInvalid();
			}
		} else {
			parserLogger.log(Level.INFO, "make invalid Command instead");
			return new CommandInvalid();
		}
	}
	
	protected static Command makeClear(String content){
		parserLogger.log(Level.INFO, "make clear Command");
		if(content.equals("")){
			return new CommandClear();
		}else{
			return new CommandInvalid();
		}
	}
	
	protected static Command makeMove(String content){
		parserLogger.log(Level.INFO, "make move Command");
		ArrayList<String> indexes = sliceContent(content);
		if ((isPositiveInt(indexes.get(0)))
				&& (isPositiveInt(indexes.get(1)))) {
			try{
				System.out.println(indexes.get(0));
				System.out.println(indexes.get(1));
				int origin = Integer.parseInt(indexes.get(0));
				int destination = Integer.parseInt(indexes.get(1));
				return new CommandMove(origin, destination);
			}catch(Exception e){
				return new CommandInvalid();
			}
		} else {
			parserLogger.log(Level.INFO, "make invalid Command instead");
			return new CommandInvalid();
		}
	}
	
	protected static Command makeSearch(String content){
		parserLogger.log(Level.INFO, "make search Command");
		return new CommandSearch(content);
	}
	
	protected static Command makeShowAll(){
		parserLogger.log(Level.INFO, "make showall Command");
		return new CommandShowAll();
	}
	
	protected static Command makeDone(String content){
		parserLogger.log(Level.INFO, "make done Command");
		if (isPositiveInt(content)) {
			try{
				return new CommandDone(Integer.parseInt(content));
			}catch (Exception e){
				return new CommandInvalid();
			}
		} else {
			return new CommandInvalid();
		}
	}
	
	protected static Command makeClearDone(){
		parserLogger.log(Level.INFO, "make cleardone Command");
		return new CommandClearDone();
	}
	
	protected static Command makeRecur(String content){
		parserLogger.log(Level.INFO, "make recur Command");
		ArrayList<String> contents = sliceContent(content);
		String index = contents.get(0);
		String period = contents.get(1);
		if (isPositiveInt(index) && isValidPeriod(period)) {
			try{
				return new CommandRecur(Integer.parseInt(index), period);
			}catch (Exception e){
				return new CommandInvalid();
			}
		} else {
			return new CommandInvalid();
		}
	}
	
	protected static Command makeRemind(String content){
		parserLogger.log(Level.INFO, "make remind Command");
		try {
			ArrayList<String> contents = sliceContent(content);
			String index = contents.get(0);
			String date = contents.get(1);
			String time = contents.get(2);
			return new CommandRemind(Integer.parseInt(index), date, time);
		} catch (Exception e) {
			parserLogger.log(Level.INFO, "make invalid Command instead");
			return new CommandInvalid();
		}
	}
	
	protected static Command makeLoad(String content){
		parserLogger.log(Level.INFO, "make load Command");
		return new CommandLoad(content);
	}
	
	protected static Command makeUndo(){
		parserLogger.log(Level.INFO, "make undo Command");
		return new CommandUndo();
	}
	
	protected static Command makeExit(){
		parserLogger.log(Level.INFO, "make exit Command");
		return new CommandExit(true);
	}
	
	protected static Command makeInvalid(){
		parserLogger.log(Level.INFO, "make invalid Command");
		return new CommandInvalid();
	}
	//End of Command Maker Methods
	
	//Methods to make Tasks(Floating, Timed and Deadline tasks).
	// End of segment: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\parser\ParserUtility.java





	/**
	 * origin: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\parser\ParserUtility.java
	 */

	protected static ArrayList<String> sliceContent(String content) {
		ArrayList<String> slicedContent = new ArrayList<String>();
		String[] contentPieces = content.split("\\s+");
		for (String pieceOfContent : contentPieces) {
			slicedContent.add(pieceOfContent);
		}
		return slicedContent;
	}
	//End of Content processer methods
	
	//Validation methods to detect if a String content piece is as required
	// End of segment: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\parser\ParserUtility.java





	/**
	 * origin: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\parser\ParserUtility.java
	 */

	protected static boolean isPositiveInt(String content) {
		try {
			int i = Integer.parseInt(content);
			return (i > 0 ? true : false);
		} catch (NumberFormatException nfe) {
			parserLogger.log(Level.INFO, "Command Content is invalid");
			return false;
		}
	}

	// End of segment: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\parser\ParserUtility.java





	/**
	 * origin: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\parser\ParserUtility.java
	 */

	protected static boolean isValidPeriod(String content){
		if(content.equals("hourly")||content.equals("daily")||content.equals("weekly")||content.equals("monthly")||content.equals("yearly")){
			return true;
		}else{
			return false;
		}
	}
	//End of Validation methods
}

	// End of segment: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\parser\ParserUtility.java





	/**
	 * origin: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\storage\InMemStorage.java
	 */

	public boolean move(int originIndex, int destinationIndex) {
		assert(originIndex>=0&&originIndex<getTasks().size());
		assert(destinationIndex>=0&&destinationIndex<getTasks().size());
		Done movedTask = getTasks().remove(originIndex);
		getTasks().add(destinationIndex, movedTask);
		updateTaskID();
		if (jsonStorage.store(getTasks()) == true) {
			return true;
		}

		return false;
	}

	public boolean clearDoneTasks() {
		List<Done> tasks = getTasks();
		int size = tasks.size();
		for (int i = size-1; i >= 0; i--) {
			if (tasks.get(i).isCompleted()) {
				tasks.remove(i);
			}
		}
		updateTaskID();

		if (jsonStorage.store(getTasks()) == true) {
			return true;
		}

		return false;
	}
	
	// End of segment: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\storage\InMemStorage.java





	/**
	 * origin: C:\Users\Jerry\eclipse_workspace\CS2103Project\test\com\done\command\TestCommand.java
	 */

	@Test
	public void testCommandAdd() {
		Command command = new CommandAdd(new DoneFloatingTask("aaa"));
		assertEquals(command.getCommandType(), CommandType.ADD);
	}

	@Test
	public void testCommandDelete() throws Exception {
		Command command = new CommandDelete(1);
		assertEquals(command.getCommandType(), CommandType.DELETE);
	}

	@Test
	public void testCommandClear() {
		Command command = new CommandClear();
		assertEquals(command.getCommandType(), CommandType.CLEAR);
	}

	@Test
	public void testCommandSearch() {
		Command command = new CommandSearch("aaa");
		assertEquals(command.getCommandType(), CommandType.SEARCH);
	}

	@Test
	public void testCommandRecur() throws Exception {
		Command command = new CommandRecur(1, "weekly");
		assertEquals(command.getCommandType(), CommandType.RECUR);
	}

	@Test
	public void testCommandRemind() {
		// Command command = new CommandRemind(1,"weekly");
		// assertEquals(command.getCommandType(), CommandType.REMIND);
	}

}

	// End of segment: C:\Users\Jerry\eclipse_workspace\CS2103Project\test\com\done\command\TestCommand.java





	/**
	 * origin: C:\Users\Jerry\eclipse_workspace\CS2103Project\test\com\done\parser\TestCommandParser.java
	 */

	@Test
	//Equivalence partition: String content that is positive integer
	public void testGetCommandDeleteValid() {
		Command validCommandDelete = testedParser.parseInputToMakeCommand("delete 1");
		assertEquals(validCommandDelete.getCommandType(),CommandType.DELETE);
	}
	
	@Test
	//Equivalence partition: String content that is not a number
	public void testGetCommandDeleteInvalid(){
		Command invalidCommandDelete = testedParser.parseInputToMakeCommand("delete aaa");
		assertEquals(invalidCommandDelete.getCommandType(), CommandType.INVALID);
	}

	@Test
	public void testGetCommandType() {
		assertEquals(testedParser.getCommandType("add 1"), CommandType.ADD);
	}

	@Test
	public void testGetCommandContent() {
		assertEquals(testedParser.getCommandContent("add abcde"), "abcde");
	}

}

	// End of segment: C:\Users\Jerry\eclipse_workspace\CS2103Project\test\com\done\parser\TestCommandParser.java





