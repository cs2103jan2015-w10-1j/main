//@author: a0111830x



	/**
	 * origin: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\command\CommandAdd.java
	 */

	@Override
	public void execute() throws Exception {
		if (this.task != null) {
			InMemStorage memory = InMemStorage.getInstance();
			memory.store(task);
		} else {
			throw new Exception("TaskNullException");
		}

	}

	@Override
	public void undo() {
		if (task.getType().equals(TaskType.TIMED)) {
			reminderTask.stopTimer();
			CommandDelete command = new CommandDelete(task);
			command.execute();
		} else {
			CommandDelete command = new CommandDelete(task);
			command.execute();
		}
	}
	
	// End of segment: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\command\CommandAdd.java





	/**
	 * origin: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\command\CommandClear.java
	 */

	@Override
	public void execute() {
		InMemStorage.getInstance().delete(null, true);

	}
	
	// End of segment: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\command\CommandClear.java





	/**
	 * origin: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\command\CommandDelete.java
	 */

	@Override
	public void execute() {
		InMemStorage memory = InMemStorage.getInstance();
		if (task == null) {
			this.task = memory.getTask(deleteIndex);
			memory.delete(task, false);
		} else {
			memory.delete(task, false);
		}
	}

	@Override
	public void undo() {
		CommandAdd command = new CommandAdd(task);

		try {
			command.execute();
		} catch (Exception e) {
			e.printStackTrace();
		}

	}
	
	// End of segment: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\command\CommandDelete.java





	/**
	 * origin: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\command\CommandLoad.java
	 */

	@Override
	public void execute() {
		JsonStorage jsonStorage = JsonStorage.getInstance();
		InMemStorage inMemStorage = InMemStorage.getInstance();

		jsonStorage.setJsonNameToPref(DIR_TASKS + jsonName);
		inMemStorage.loadNew();

	}

	// End of segment: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\command\CommandLoad.java





	/**
	 * origin: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\command\CommandSearch.java
	 */

	@Override
	public void execute() {
		InMemStorage memory = InMemStorage.getInstance();
		List<Done> tasks = memory.getTasks();
		memory.emptyWorkingTasks();

		for (int i = 0; i < tasks.size(); i++) {
			Done task = tasks.get(i);
			if (task.getTitle().contains(searchString)) {
				memory.addIntoWorkingTask(task);
			}
			// check if this is a timedTask
			else if (task.getType().equals(TaskType.TIMED)) {
				// check the event date is equal to searchString
				DoneTimedTask dtt = (DoneTimedTask) task;
				if (dtt.getDateString().equals(searchString)) {
					memory.addIntoWorkingTask(task);
				}
			}

			// check if this is a deadlineTask
			else if (task.getType().equals(TaskType.DEADLINE)) {
				// check the deadline date is equal to searchString
				DoneDeadlineTask ddt = (DoneDeadlineTask) task;
				if (ddt.getDateString().equals(searchString)) {
					memory.addIntoWorkingTask(task);
				}
			}
		}

	}

	// End of segment: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\command\CommandSearch.java





	/**
	 * origin: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\command\CommandUndo.java
	 */

	@Override
	public void execute() throws Exception {
		Command command = InMemStorage.getInstance().popFromUndoStack();
		command.undo();
	}
	
	// End of segment: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\command\CommandUndo.java





	/**
	 * origin: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\model\Done.java
	 */

	public static enum TaskType {
		FLOATING, TIMED, DEADLINE;
	}

	// Task without tag constructor
	public Done(String title) {
		this.title = title;
		this.setCompleted(false);
	}

	// Task with tag constructor
	public Done(String title, String tag) {
		this.title = title;
		this.setTag(tag);
		this.setCompleted(false);
	}

	// End of segment: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\model\Done.java





	/**
	 * origin: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\model\DoneDeadlineTask.java
	 */

	public String getEndTime() {
		SimpleDateFormat sdf = new SimpleDateFormat("d MMM yyyy HH:mm");
		return sdf.format(endTime);
	}
	
	// This method returns you a ddMMyyyy for search purpose
	public String getDateString(){
		SimpleDateFormat sdf = new SimpleDateFormat("ddMMyyyy");
		return sdf.format(endTime);
	}

}

	// End of segment: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\model\DoneDeadlineTask.java





	/**
	 * origin: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\model\DoneTimedTask.java
	 */

	public String getStartTime() {
		// SimpleDateFormat sdf = new SimpleDateFormat("d MMM yyyy HH:mm");
		SimpleDateFormat sdf = new SimpleDateFormat("d MMM HH:mm");
		return sdf.format(startTime);
	}
	
	// This method returns you a ddMMyyyy for search purpose
	public String getDateString(){
		SimpleDateFormat sdf = new SimpleDateFormat("ddMMyyyy");
		return sdf.format(startTime);
		
	}

	// End of segment: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\model\DoneTimedTask.java





	/**
	 * origin: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\model\DoneTimedTask.java
	 */

	public long getStartTimeLong() {
		return startTime;
	}

	// End of segment: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\model\DoneTimedTask.java





	/**
	 * origin: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\model\DoneTimedTask.java
	 */

	public String getEndTime() {
		SimpleDateFormat sdf = new SimpleDateFormat("d MMM HH:mm");
		return sdf.format(endTime);
	}

	public long getEndTimeLong() {
		return endTime;
	}

	// End of segment: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\model\DoneTimedTask.java





	/**
	 * origin: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\parser\ParserUtility.java
	 */

	protected static Done defineTask(String commandContent) throws Exception {
		Done task;
		boolean isTimed = false;
		boolean isDeadline = false;
		int startDateIndex = 0;
		int startTimeIndex = 0;
		int endDateIndex = 0;
		int endTimeIndex = 0;

		ArrayList<String> contentParts = sliceContent(commandContent);
		for (int i = 0; i < contentParts.size(); i++) {
			// check for ..s and ..e parameters
			if (contentParts.get(i).equals("..s")) {
				// timed task
				isTimed = true;
				if (contentParts.get(i + 2).equals("..e")
						&& isValidTime(contentParts.get(i + 1))) {
					String currentDate = DateTime.now().toString("ddMM");
					contentParts.add(i + 1, currentDate);
				} else if (!isValidDate(contentParts.get(i + 1))
						|| !isValidTime(contentParts.get(i + 2))) {
					throw new Exception("Invalid Input");
				}
				startDateIndex = i + 1;
				startTimeIndex = i + 2;
				// if input consist only of ..e, we take the current time as the
				// start
			} else if (contentParts.get(i).equals("..e")) {
				isTimed = true;
				if (isValidTime(contentParts.get(i + 1))
						&& (i == contentParts.size() - 2 || !isValidTime(contentParts
								.get(i + 2)))) {
					String currentDate = DateTime.now().toString("ddMM");
					contentParts.add(i + 1, currentDate);
				} else if (!isValidDate(contentParts.get(i + 1))
						|| !isValidTime(contentParts.get(i + 2))) {
					throw new Exception("Invalid Input");
				}
				endDateIndex = i + 1;
				endTimeIndex = i + 2;
				if (startDateIndex == 0 && startTimeIndex == 0) {
					startDateIndex = i + 1;
					startTimeIndex = i + 2;
					String currentDate = DateTime.now().toString("ddMM");
					String currentTime = DateTime.now().toString("HHmm");
					contentParts.add(startDateIndex, currentDate);
					contentParts.add(startTimeIndex, currentTime);
					endDateIndex = i + 3;
					endTimeIndex = i + 4;
				}
				break;
			} else if (contentParts.get(i).equals("..d")) {
				// deadline task
				isDeadline = true;
				endDateIndex = i + 1;
				endTimeIndex = i + 2;
				break;
			}
		}
		if (isTimed) {
			// if content contains end time and/or start time
			// we generate (new) timedTask
			// and return timedTask
			parserUtilityLogger.log(Level.INFO, MESSAGE_MAKE_TIMED);
			task = addTimed(contentParts, startDateIndex, startTimeIndex,
					endDateIndex, endTimeIndex);
			return task;

		} else if (isDeadline) {
			// if content has date and time
			// we generate new deadlineTask
			// and return deadlineTask
			parserUtilityLogger.log(Level.INFO, MESSAGE_MAKE_DEADLINE);
			task = addDeadline(contentParts, endTimeIndex, endDateIndex);
			return task;
		}
		if (!commandContent.equals(null) && !commandContent.equals("")) {
			// if content isn't null or ""
			// we generate new floatingTask
			// we return floatingTask
			parserUtilityLogger.log(Level.INFO, MESSAGE_MAKE_FLOATING);
			task = new DoneFloatingTask(commandContent);
			return task;
		}
		// else return null or throw exception
		return null;

	}

	// End of segment: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\parser\ParserUtility.java





	/**
	 * origin: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\parser\ParserUtility.java
	 */

	protected static Done addTimed(ArrayList<String> contentParts,
			int startDateIndex, int startTimeIndex, int endDateIndex,
			int endTimeIndex) {
		String startDate = "";
		String startTime = "";
		String endDate = "";
		String endTime = "";
		String currentYear = DateTime.now().toString("yyyy");
		long startTimeValue = 0;
		long endTimeValue = 0;

		Done task = null;
		DateTimeFormatter dtf = DateTimeFormat.forPattern("ddMMyyyy HHmm");

		// obtain title of task from input
		StringBuilder taskTitleBuilder = new StringBuilder();
		for (int i = 0; i < startDateIndex - 1; i++) {
			if (i == startDateIndex - 2) {
				taskTitleBuilder.append(contentParts.get(i));
			} else {
				taskTitleBuilder.append(contentParts.get(i) + " ");
			}
		}
		String taskTitle = taskTitleBuilder.toString();

		// obtain contents of various parameters
		startDate = contentParts.get(startDateIndex);
		startTime = contentParts.get(startTimeIndex);
		endDate = contentParts.get(endDateIndex);
		endTime = contentParts.get(endTimeIndex);

		// convert time to milliseconds
		DateTime startDateTime = dtf.parseDateTime(startDate + currentYear
				+ " " + startTime);
		DateTime endDateTime = dtf.parseDateTime(endDate + currentYear + " "
				+ endTime);
		startTimeValue = startDateTime.getMillis();
		endTimeValue = endDateTime.getMillis();

		task = new DoneTimedTask(taskTitle, startTimeValue, endTimeValue);
		return task;
	}

	// End of segment: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\parser\ParserUtility.java





	/**
	 * origin: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\parser\ParserUtility.java
	 */

	protected static Done addDeadline(ArrayList<String> contentParts,
			int timeIndex, int dateIndex) {
		Done task = null;

		// obtain title of task
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < dateIndex - 1; i++) {
			if (i == dateIndex - 2) {
				sb.append(contentParts.get(i));
			} else {
				sb.append(contentParts.get(i) + " ");
			}

		}
		String taskTitle = sb.toString();

		// obtain date time and format it to long milliseconds
		DateTimeFormatter dtf = DateTimeFormat.forPattern("ddMMyyyy HHmm");
		DateTime date = dtf.parseDateTime(contentParts.get(dateIndex) + " "
				+ contentParts.get(timeIndex));
		task = new DoneDeadlineTask(taskTitle, date.getMillis());
		return task;

	}

	// End of Task Maker Methods

	// Methods to process content Strings, like removing and getting first words
	// End of segment: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\parser\ParserUtility.java





	/**
	 * origin: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\parser\ParserUtility.java
	 */

	protected static String removeFirstWord(String userCommand) {
		String returnStr = getFirstWord(userCommand).trim();
		returnStr = userCommand.substring(returnStr.length());
		return returnStr.trim();
	}

	protected static String getFirstWord(String userCommand) {
		return userCommand.trim().split("\\s+")[0];
	}

	// End of segment: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\parser\ParserUtility.java





	/**
	 * origin: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\storage\DoneAdapter.java
	 */

	@Override
	public List<Done> deserialize(JsonElement arg0, Type arg1,
			JsonDeserializationContext arg2) throws JsonParseException {
		List<Done> result = new ArrayList<Done>();
		JsonArray jsonArray = null;
		try {
			jsonArray = arg0.getAsJsonArray();
		} catch (IllegalStateException e) {
			e.printStackTrace();
			System.exit(0);
		}

		for (JsonElement out : jsonArray) {
			JsonObject jsonObj = out.getAsJsonObject();
			JsonElement element = jsonObj.get("task");
			String classType = jsonObj.get("class").getAsString();

			result.add(arg2.deserialize(element, map.get(classType)));

		}
		return result;
	}

	@Override
	public JsonElement serialize(List<Done> arg0, Type arg1,
			JsonSerializationContext arg2) {

		JsonArray result = new JsonArray();
		for (Done out : arg0) {
			JsonObject obj = new JsonObject();
			JsonElement element = arg2.serialize(out);
			obj.addProperty("class", out.getClass().getSimpleName());
			obj.add("task", element);
			result.add(obj);
		}

		return result;
	}

}

	// End of segment: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\storage\DoneAdapter.java





	/**
	 * origin: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\storage\InMemStorage.java
	 */

package com.done.storage;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Stack;
import java.util.logging.Level;

import com.done.command.Command;
import com.done.model.Done;

public class InMemStorage {
	private static InMemStorage instance = null;

	private static final String MESSAGE_SET_INCOMPLETE = "Set Task Incomplete";
	private static final String MESSAGE_PUSH_UNDO = "Push command to Undo stack";
	private static final String MESSAGE_RETRIEVE_UNDO = "Retreive command from Undo stack";
	private static final String MESSAGE_SET_COMPLETED = "Set Task Completed";
	private static final String MESSAGE_CLEAR_ALL = "Clear all Done tasks";
	private static final String MESSAGE_MOVE_TASK = "Move task";
	private static final String MESSAGE_EDIT_TASK = "Edit task";
	private static final String MESSAGE_DELETE_TASK = "Delete task";
	private static final String MESSAGE_STORE_MEMORY = "Store to memory";
	private static final String MESSAGE_SEARCH_RESULT = "Get search result";
	private static final String MESSAGE_LOAD_NEW = "Load from new JSON";
	private static final String ERROR_EMPTY_STACK = "Command Stack is empty!";

	private static final int ARRAY_POSITION_OFFSET = 1;

	private List<Done> tasks;
	private List<Done> workingTasks;
	private Stack<Command> undoStack;

	private JsonStorage jsonStorage;

	private InMemStorage() {
		StorageLogger.setUpLogger();
		jsonStorage = JsonStorage.getInstance();
		this.setTasks(jsonStorage.load());
		this.undoStack = new Stack<Command>();
		workingTasks = tasks;
	}

	public static synchronized InMemStorage getInstance() {
		if (instance == null) {
			instance = new InMemStorage();
		}

		return instance;
	}

	public Done getTask(int id) {
		return getTasks().get(id - ARRAY_POSITION_OFFSET);
	}

	/**
	 * Method which loads the new JSON into memory from a different file.
	 */
	public void loadNew() {
		StorageLogger.getStorageLogger().log(Level.INFO, MESSAGE_LOAD_NEW);
		jsonStorage.setNewJson(true);
		this.setTasks(jsonStorage.load());
		jsonStorage.setNewJson(false);
	}

	public List<Done> load() {
		return getTasks();
	}

	/**
	 * Retrieve the List of tasks which are filtered by keyword during search.
	 * 
	 * @return Filtered list of tasks.
	 */
	public List<Done> loadSearchResult() {
		StorageLogger.getStorageLogger().log(Level.INFO, MESSAGE_SEARCH_RESULT);
		return getWorkingTasks();
	}

	/**
	 * Stores the task into memory.
	 * 
	 * @param task
	 *            Current task being added.
	 * @return Whether it is successful.
	 */
	public boolean store(Done task) {
		StorageLogger.getStorageLogger().log(Level.INFO, MESSAGE_STORE_MEMORY);
		assert task != null;
		getTasks().add(0, task);
		updateTaskID();
		if (jsonStorage.store(getTasks()) == true) {
			return true;
		}

		return false;
	}

	/**
	 * Deletes a task or clear all from memory.
	 * 
	 * @param task
	 *            Current task to be deleted.
	 * @param isDeleteAll
	 *            Used to determine if it is clear all.
	 * @return Whether it is successful.
	 */
	public boolean delete(Done task, boolean isDeleteAll) {
		StorageLogger.getStorageLogger().log(Level.INFO, MESSAGE_DELETE_TASK);
		// isDeleteAll used for clear command
		// if true is a clear
		// else is a normal delete
		if (isDeleteAll) {
			assert task == null;
			getTasks().clear();
		} else {
			assert task != null;
			getTasks().remove(task);
			updateTaskID();
		}
		if (jsonStorage.store(getTasks()) == true) {
			return true;
		}

		return false;
	}

	/**
	 * Replaces the new input task with the index existing in memory.
	 * 
	 * @param task
	 *            New task to be added.
	 * @param editIndex
	 *            Index of the task in memory to be replaced
	 * @return Whether is it successful.
	 */
	public boolean edit(Done task, int editIndex) {
		StorageLogger.getStorageLogger().log(Level.INFO, MESSAGE_EDIT_TASK);
		assert task != null;

		getTasks().set(editIndex, task);
		updateTaskID();
		if (jsonStorage.store(getTasks()) == true) {
			return true;
		}

		return false;
	}

	// End of segment: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\storage\InMemStorage.java





	/**
	 * origin: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\storage\InMemStorage.java
	 */

	/**
	 * Marks the input task as completed.
	 * 
	 * @param task
	 *            Task to be marked as complete.
	 */
	public void setCompleted(Done task) {
		StorageLogger.getStorageLogger().log(Level.INFO, MESSAGE_SET_COMPLETED);
		assert task != null;

		getTasks().get(task.getId() - ARRAY_POSITION_OFFSET).setCompleted(true);
		jsonStorage.store(getTasks());
	}

	/**
	 * Marks the input task as incomplete.
	 * 
	 * @param task
	 *            Task to be marked as incomplete.
	 */
	public void setIncomplete(Done task) {
		StorageLogger.getStorageLogger()
				.log(Level.INFO, MESSAGE_SET_INCOMPLETE);
		assert task != null;

		getTasks().get(task.getId() - ARRAY_POSITION_OFFSET)
				.setCompleted(false);
		jsonStorage.store(getTasks());
	}

	// Stack used for Undo
	/**
	 * Pushes the input command to the Undo stack.
	 * 
	 * @param command
	 *            The current command from the input.
	 */
	public void pushToUndoStack(Command command) {
		StorageLogger.getStorageLogger().log(Level.INFO, MESSAGE_PUSH_UNDO);
		this.undoStack.push(command);
	}

	/**
	 * Remove from the Undo stack.
	 * 
	 * @return The last command used for executing undo.
	 * @throws Exception
	 *             If stack is empty.
	 */
	public Command popFromUndoStack() throws Exception {
		StorageLogger.getStorageLogger().log(Level.INFO, MESSAGE_RETRIEVE_UNDO);
		if (undoStack.isEmpty()) {
			throw new Exception(ERROR_EMPTY_STACK);
		}
		return this.undoStack.pop();
	}

	public void emptyWorkingTasks() {
		this.workingTasks = new ArrayList<Done>();
	}

	public void addIntoWorkingTask(Done task) {
		assert task != null;

		this.workingTasks.add(task);
	}

	// For updating ID to be always in increasing order 1 ... n
	private void updateTaskID() {
		Iterator<Done> listIterator = getTasks().iterator();
		int i = 1;
		while (listIterator.hasNext()) {
			listIterator.next().setId(i);
			i++;
		}
	}

	// End of segment: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\storage\InMemStorage.java





	/**
	 * origin: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\storage\JsonStorage.java
	 */

package com.done.storage;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;
import java.util.logging.Level;

import com.done.model.Done;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonIOException;
import com.google.gson.reflect.TypeToken;

public class JsonStorage {
	private static JsonStorage instance = null;

	private static final String DIR_PREF = "prefs//";
	private static final String DIR_TASKS = "tasks//";
	private static final String FILE_JSON_EXT = ".json";
	private static final String FILE_TASKS_JSON = DIR_TASKS + "tasks";
	private static final String FILE_PREFS_XML = DIR_PREF + "done_prefs.xml";

	private static final String MESSAGE_STORE_JSON = "Store to JSON";
	private static final String MESSAGE_SET_JSON_NAME = "Setting JSON name: %1$s";
	private static final String MESSAGE_RETRIEVE_JSON = "Retrieving JSON name: %1$s";
	private static final String ERROR_WRITE_FILE = "Unable to write file!";
	private static final String ERROR_FILE_NOT_FOUND = "File not found!";
	private static final String ERROR_READ_PREF_FILE = "Unable to read preference file! Creating default.";
	private static final String ERROR_READ_JSON_FILE = "Unable to read JSON file, creating new empty List";

	private Gson gson;
	private Properties pref;
	private String jsonName;
	private boolean isNewJson;

	private JsonStorage() {
		setUpDirectories();
		this.gson = new GsonBuilder()
				.registerTypeAdapter(Done.class, new DoneAdapter())
				.setPrettyPrinting().serializeNulls().create();
		pref = new Properties();
		jsonName = getJsonNameFromPref();
		isNewJson = false;
	}

	public static synchronized JsonStorage getInstance() {
		if (instance == null) {
			instance = new JsonStorage();
		}

		return instance;
	}

	/**
	 * Return the List of tasks as Done object from JSON file. If file is not
	 * found, returns an empty list.
	 * 
	 * @return List of tasks that are loaded from JSON file.
	 */
	public List<Done> load() {
		StorageLogger.getStorageLogger().log(Level.INFO, "Load from JSON");
		FileReader inFileRead = null;
		List<Done> tasks = null;

		// isNewJson to check if it's a different filename from preference file
		if (isNewJson) {
			jsonName = getJsonNameFromPref();
		}
		File inFile = openFile(jsonName);

		// read the actual JSON file
		try {
			inFileRead = new FileReader(jsonName);
		} catch (IOException e) {
			StorageLogger.getStorageLogger().log(Level.WARNING,
					ERROR_FILE_NOT_FOUND, e);
			// if IOException occurs while reading file, return empty List of
			// Done
			return new ArrayList<Done>();
		}

		// check if the JSON file has objects
		// if not return empty new ArrayList for loading
		if (inFile.length() <= 0) {
			assert inFile.length() <= 0; // assert that the file is indeed empty
			return new ArrayList<Done>();
		} else {
			assert inFile.length() > 0;
			// else get from JSON object in file into ArrayList
			Type collectionType = new TypeToken<Done>() {
			}.getType();
			try {
				tasks = gson.fromJson(inFileRead, collectionType);
				assert tasks != null; // assert that the tasks ArrayList is not
										// null
			} catch (JsonIOException e) {
				StorageLogger.getStorageLogger().log(Level.WARNING,
						ERROR_READ_JSON_FILE, e);
				// if JsonIOException occurs, return an empty List of Done
				return new ArrayList<Done>();
			}
			return tasks;
		}

	}

	/**
	 * Stores the List of tasks from memory to JSON file.
	 * 
	 * @param task
	 *            Task from memory.
	 * @return Whether it is successful.
	 */
	public boolean store(List<Done> task) {
		StorageLogger.getStorageLogger().log(Level.INFO, MESSAGE_STORE_JSON);

		try {
			FileWriter outFile = new FileWriter(jsonName);
			outFile.write(gson.toJson(task, Done.class));
			outFile.flush();
			outFile.close();
			return true;
		} catch (IOException e) {
			StorageLogger.getStorageLogger().log(Level.WARNING,
					ERROR_WRITE_FILE, e);
			// if IOException occurs, return false for Logic to set isSuccessful
			// to false;
			return false;
		}
	}

	/**
	 * Set the JSON name to preference file.
	 * 
	 * @param jsonName
	 *            JSON name that is to be set.
	 * @return Whether it is successful.
	 */
	public boolean setJsonNameToPref(String jsonName) {
		StorageLogger.getStorageLogger().log(Level.INFO,
				String.format(MESSAGE_SET_JSON_NAME, jsonName));
		pref.setProperty("jsonName", jsonName + FILE_JSON_EXT);
		try {
			File prefFile = openFile(FILE_PREFS_XML);
			pref.storeToXML(new FileOutputStream(prefFile), "store to XML");
			return true;
		} catch (Exception e) {
			StorageLogger.getStorageLogger().log(Level.WARNING,
					ERROR_WRITE_FILE, e);
			// if IOException occurs, return false for Logic to set isSuccessful
			// to false;
			return false;
		}
	}

	/**
	 * Retrieve JSON name from preference file. If the preference file does not
	 * exist, create preference file with default JSON filename "tasks.json".
	 * 
	 * @return JSON file name in String.
	 */
	public String getJsonNameFromPref() {

		try {
			File prefFile = openFile(FILE_PREFS_XML);
			pref.loadFromXML(new FileInputStream(prefFile));
		} catch (IOException e) {
			StorageLogger.getStorageLogger().log(Level.WARNING,
					ERROR_READ_PREF_FILE);
			// If IOException occur, set default preference file name
			setJsonNameToPref(FILE_TASKS_JSON);
		}
		jsonName = pref.getProperty("jsonName", FILE_TASKS_JSON);
		StorageLogger.getStorageLogger().log(Level.INFO,
				String.format(MESSAGE_RETRIEVE_JSON, jsonName));
		return jsonName;

	}

	// Utility Methods
	private static File openFile(String fileName) {
		File file = new File(fileName);

		if (!file.exists()) {
			try {
				file.createNewFile();
			} catch (IOException e) {
				System.exit(0);
			}
		}
		return file;
	}

	private void setUpDirectories() {
		File tasksDir = new File(DIR_TASKS);
		File prefDir = new File(DIR_PREF);
		if (!tasksDir.exists()) {
			tasksDir.mkdir();
		}
		if (!prefDir.exists()) {
			prefDir.mkdir();
		}

	}

	// End of segment: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\storage\JsonStorage.java





	/**
	 * origin: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\storage\StorageLogger.java
	 */

	public static void setUpLogger() {
		SimpleFormatter sf = new SimpleFormatter();

		try {
			String out = new SimpleDateFormat(
					"'StorageLog-'dd-MM-yyyy HHmm'.log'").format(new Date());
			File file = new File(DIR_LOG);
			file.mkdir();
			fileHandler = new FileHandler(DIR_LOG + out);
			storageLogger.addHandler(fileHandler);
			fileHandler.setFormatter(sf);
		} catch (SecurityException | IOException e) {
			storageLogger.log(Level.WARNING, "Unable to read file!", e);
		}
	}

	// End of segment: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\storage\StorageLogger.java





	/**
	 * origin: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\task\TaskReminder.java
	 */

package com.done.task;

import java.util.Timer;
import java.util.TimerTask;

import javafx.application.Platform;
import javafx.util.Duration;

import org.controlsfx.control.Notifications;
import org.joda.time.DateTime;
import org.joda.time.LocalDateTime;
import org.joda.time.format.DateTimeFormat;
import org.joda.time.format.DateTimeFormatter;

import com.done.model.Done;
import com.done.model.DoneTimedTask;

public class TaskReminder {
	Timer timer;


	public TaskReminder(DoneTimedTask done) {

		long timeToRemind = done.getEndTimeLong() - DateTime.now().getMillis();

		timer = new Timer();
		timer.schedule(new DoneReminderTimedTask(done),
				(timeToRemind));
	}

	public TaskReminder(Done done, String remindDate, String remindTime) {
		DateTimeFormatter dtf = DateTimeFormat.forPattern("ddMMyyyy HHmm");
		DateTime dateTime = dtf.parseDateTime(remindDate + " " + remindTime);
		long currentTime = LocalDateTime.now().getMillisOfDay();
		long endTimeValue = dateTime.getMillisOfDay();

		timer = new Timer();
		timer.schedule(new DoneReminder(done), (endTimeValue - currentTime));
	}

	public void stopTimer() {
		timer.cancel();
	}

	class DoneReminder extends TimerTask {

		private final Done done;

		public DoneReminder(Done done) {
			this.done = done;
		}

		@Override
		public void run() {
			Platform.runLater(new Runnable() {
				public void run() {
					Notifications.create().title("Done! Reminder")
							.text("Reminder for: " + done.getTitle())
							.hideAfter(Duration.INDEFINITE).darkStyle()
							.showWarning();
					timer.cancel();
				}
			});
		}

	}

	class DoneReminderTimedTask extends TimerTask {

		private final DoneTimedTask done;

		public DoneReminderTimedTask(DoneTimedTask done) {
			this.done = done;
		}

		@Override
		public void run() {
			Platform.runLater(new Runnable() {
				public void run() {
					Notifications.create().title("Done! Timed Task")
							.text("Time is up for: " + done.getTitle())
							.hideAfter(Duration.INDEFINITE).darkStyle()
							.showWarning();
					timer.cancel();
				}
			});
		}

	}

}

	// End of segment: C:\Users\Jerry\eclipse_workspace\CS2103Project\src\com\done\task\TaskReminder.java





	/**
	 * origin: C:\Users\Jerry\eclipse_workspace\CS2103Project\test\com\done\DoneProgram.java
	 */

// System tests
package com.done;

import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.assertThat;
import static org.junit.Assert.assertTrue;

import org.junit.Before;
import org.junit.Test;

import com.done.command.Command;
import com.done.command.Command.CommandType;
import com.done.logic.Logic;
import com.done.logic.LogicFacade;
import com.done.parser.CommandParser;
import com.done.result.ExecutionResult;
import com.done.storage.InMemStorage;

public class DoneProgram {

	@Test
	public void testAddFloatingFromFacade() {
		String input = "add facade test";
		InMemStorage inMemStorage = InMemStorage.getInstance();

		LogicFacade logicFacade = new LogicFacade();
		ExecutionResult result = logicFacade.getExecutionResult(input);

		assertThat(result.getCommandContent(), is("facade test"));
		assertThat(result.getCommandType(), is(CommandType.ADD));
		assertTrue(inMemStorage.getTasks().size() > 0);

	}

	@Test
	public void testAddFloatingFromLogic() {
		Logic logic = new Logic();
		InMemStorage inMemStorage = InMemStorage.getInstance();

		String input = "add logic test";

		String commandContent = logic.getCmdContent(input);
		CommandParser parser = CommandParser.getInstance();
		Command command = parser.parseInputToMakeCommand(input);

		logic.executeCommand(command);

		assertThat(logic.isSuccessful(), is(true));
		assertThat(commandContent, is("logic test"));
		assertThat(logic.getCmdType(input), is(CommandType.ADD));
		assertThat(command.getCommandType(), is(CommandType.ADD));
		assertTrue(inMemStorage.getTasks().size() > 0);
	}

	@Test
	public void testUndo() {
		InMemStorage inMemStorage = InMemStorage.getInstance();
		String input = "add undo test";
		String undoInput = "undo";

		// test with add
		LogicFacade logicFacade = new LogicFacade();
		ExecutionResult resultAdd = logicFacade.getExecutionResult(input);
		assertTrue(resultAdd.isSuccessful());
		// with an empty list, add one task should return size of 1
		assertThat(inMemStorage.getTasks().size(), is(1));

		// test undo
		ExecutionResult resultUndo = logicFacade.getExecutionResult(undoInput);
		assertTrue(resultUndo.isSuccessful());
		assertThat(resultUndo.getCommandType(), is(CommandType.UNDO));
		// after undo, means removing the added task above, size should return 0
		assertThat(inMemStorage.getTasks().size(), is(0));

	}

	@Test
	public void testSearch() {
		LogicFacade logicFacade = new LogicFacade();
		InMemStorage inMemStorage = InMemStorage.getInstance();
		ExecutionResult result = null;

		// add 4 items
		result = logicFacade.getExecutionResult("add hello");
		assertTrue(result.isSuccessful());
		assertThat(result.getCommandType(), is(CommandType.ADD));
		result = logicFacade.getExecutionResult("add hello2");
		assertTrue(result.isSuccessful());
		assertThat(result.getCommandType(), is(CommandType.ADD));
		result = logicFacade.getExecutionResult("add hello3");
		assertTrue(result.isSuccessful());
		assertThat(result.getCommandType(), is(CommandType.ADD));
		result = logicFacade.getExecutionResult("add test");
		assertTrue(result.isSuccessful());
		assertThat(result.getCommandType(), is(CommandType.ADD));

		// search for "hello", size of WorkingTask(search) List should be 3
		// as there are 3 instances of "hello"
		result = logicFacade.getExecutionResult("search hello");
		assertTrue(result.isSuccessful());
		assertThat(result.getCommandType(), is(CommandType.SEARCH));
		assertTrue(inMemStorage.getWorkingTasks().size() == 3);
	}

	@Before
	public void setUp() {
		// delete all tasks from memory and JSON first before performing tests
		InMemStorage inMemStorage = InMemStorage.getInstance();
		inMemStorage.delete(null, true);
	}

}

	// End of segment: C:\Users\Jerry\eclipse_workspace\CS2103Project\test\com\done\DoneProgram.java





	/**
	 * origin: C:\Users\Jerry\eclipse_workspace\CS2103Project\test\com\done\integration\CommandStorageTest.java
	 */

package com.done.integration;

import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.assertThat;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import com.done.command.Command;
import com.done.command.CommandAdd;
import com.done.command.CommandClear;
import com.done.command.CommandLoad;
import com.done.command.CommandSearch;
import com.done.model.DoneFloatingTask;
import com.done.storage.InMemStorage;
import com.done.storage.JsonStorage;

public class CommandStorageTest {

	InMemStorage inMem = InMemStorage.getInstance();
	JsonStorage jsonStore = JsonStorage.getInstance();

	@Before
	public void setUp() {
		// use "testJson.json" file for testing
		Command cmd = new CommandLoad("testJson");
		try {
			cmd.execute();
		} catch (Exception e) {
			System.out.println("Command failed to execute.");
		}
		// delete all tasks from memory and JSON first before performing tests
		inMem.delete(null, true);
	}

	@Test
	public void testAdd() {
		CommandAdd cmd = null;
		try {
			cmd = new CommandAdd(new DoneFloatingTask("INTEGRATION TEST"));
			cmd.execute();
			// added one task, size of inMemory should be one
			assertThat(inMem.getTasks().size(), is(1));
		} catch (Exception e) {
			System.out.println("Command failed to execute.");
		}
	}

	@Test
	public void testSearch() {
		Command cmd = null;
		try {
			// add 4 tasks with one different
			cmd = new CommandAdd(new DoneFloatingTask("INTEGRATION TEST"));
			cmd.execute();
			cmd = new CommandAdd(new DoneFloatingTask("INTEGRATION TEST2"));
			cmd.execute();
			cmd = new CommandAdd(new DoneFloatingTask("INTEGRATION TEST3"));
			cmd.execute();
			cmd = new CommandAdd(new DoneFloatingTask("HELLO WORLD!"));
			cmd.execute();

			// search for "INTEGRATION"
			cmd = new CommandSearch("INTEGRATION");
			cmd.execute();

			// memory storage should have size of 4
			assertThat(inMem.getTasks().size(), is(4));

			// memory workingTasks list should have a size of 3
			assertThat(inMem.getWorkingTasks().size(), is(3));
		} catch (Exception e) {
			System.out.println("Command failed to execute.");
		}
	}

	@Test
	public void testLoad() {
		Command cmd = null;
		try {
			// remove all from memory first
			inMem.delete(null, true);
			// add one task into current file
			cmd = new CommandAdd(new DoneFloatingTask("INTEGRATION TEST"));
			cmd.execute();
			// added one task into testJson, size of memory should be 1 
			assertThat(inMem.getTasks().size(), is(1));
			cmd = new CommandLoad("testJson2");
			cmd.execute();
			
			// loaded file testJson2, so in preferences the name should be testJson2.json
			assertThat(jsonStore.getJsonNameFromPref(), is("tasks//testJson2.json"));
			// remove all from memory first
			inMem.delete(null, true);
			
			// add 2 tasks into new file
			cmd = new CommandAdd(new DoneFloatingTask("INTEGRATIONLOAD TEST"));
			cmd.execute();
			cmd = new CommandAdd(new DoneFloatingTask("INTEGRATIONLOAD TEST2"));
			cmd.execute();
			// added 2 tasks into testJson2, size of memory should be 2 (not 3)
			assertThat(inMem.getTasks().size(), is(2));
			
		} catch (Exception e) {
			System.out.println("Command failed to execute.");
		}

	}
	
	@Test
	public void testClear() {
		Command cmd = null;
		try {
			cmd = new CommandAdd(new DoneFloatingTask("INTEGRATION TEST"));
			cmd.execute();
			cmd = new CommandAdd(new DoneFloatingTask("INTEGRATION TEST"));
			cmd.execute();
			cmd = new CommandAdd(new DoneFloatingTask("INTEGRATION TEST"));
			cmd.execute();
			// added 3 tasks, size should be 3
			assertThat(inMem.getTasks().size(), is(3));
			
			cmd = new CommandClear();
			cmd.execute();
			
			// clear executed, size should be 0
			assertThat(inMem.getTasks().size(), is(0));
			
		} catch (Exception e) {
			System.out.println("Command failed to execute.");
		}
	}

}

	// End of segment: C:\Users\Jerry\eclipse_workspace\CS2103Project\test\com\done\integration\CommandStorageTest.java





	/**
	 * origin: C:\Users\Jerry\eclipse_workspace\CS2103Project\test\com\done\integration\LogicStorageTest.java
	 */

package com.done.integration;

import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.*;

import org.junit.Before;
import org.junit.Test;

import com.done.command.Command;
import com.done.command.CommandAdd;
import com.done.command.CommandDone;
import com.done.command.CommandLoad;
import com.done.command.CommandSearch;
import com.done.command.CommandUndo;
import com.done.logic.Logic;
import com.done.model.DoneFloatingTask;
import com.done.storage.InMemStorage;
import com.done.storage.JsonStorage;

public class LogicStorageTest {

	InMemStorage inMem = InMemStorage.getInstance();
	JsonStorage jsonStore = JsonStorage.getInstance();
	Logic logic = new Logic();

	@Before
	public void setUp() {
		// use "testJson.json" file for testing
		Command cmd = new CommandLoad("testJson");
		logic.executeCommand(cmd);
		// delete all tasks from memory and JSON first before performing tests
		inMem.delete(null, true);
	}

	@Test
	public void testAdd() {
		Command cmd = new CommandAdd(new DoneFloatingTask("INTEGRATION TEST"));
		logic.executeCommand(cmd);
		// executing command should be successful
		assertTrue(logic.isSuccessful());
		// size of memory should be 1
		assertThat(inMem.getTasks().size(), is(1));
	}
	
	@Test
	public void testSearch() {
		Command cmd = new CommandAdd(new DoneFloatingTask("INTEGRATION TEST"));
		
		logic.executeCommand(cmd);
		assertTrue(logic.isSuccessful());
		
		cmd = new CommandAdd(new DoneFloatingTask("INTEGRATION TEST2"));
		logic.executeCommand(cmd);
		assertTrue(logic.isSuccessful());
		
		cmd = new CommandAdd(new DoneFloatingTask("HELLO"));
		logic.executeCommand(cmd);
		assertTrue(logic.isSuccessful());
		
		cmd = new CommandSearch("HELLO");
		logic.executeCommand(cmd);
		assertTrue(logic.isSuccessful());
		// search for HELLO, size should be 1 of the 3
		assertThat(inMem.getWorkingTasks().size(), is(1));
		
	}
	
	@Test
	public void testSetComplete() {
		Command cmd = new CommandAdd(new DoneFloatingTask("INTEGRATION TEST"));
		
		logic.executeCommand(cmd);
		assertTrue(logic.isSuccessful());
		// after adding, it is not a completed task
		assertFalse(inMem.getTask(1).isCompleted());
		
		try {
			cmd = new CommandDone(1);
			logic.executeCommand(cmd);
			assertTrue(logic.isSuccessful());
			
			// executed Done on the task, it is a completed task
			assertTrue(inMem.getTask(1).isCompleted());
		} catch (Exception e) {
			System.out.println("Command failed to execute.");
		}
	}

	@Test
	public void testUndo() {
		Command cmd = new CommandAdd(new DoneFloatingTask("INTEGRATION TEST"));
		
		logic.executeCommand(cmd);
		assertTrue(logic.isSuccessful());
		// after adding, it is not a completed task
		assertFalse(inMem.getTask(1).isCompleted());
		
		try {
			cmd = new CommandDone(1);
			logic.executeCommand(cmd);
			assertTrue(logic.isSuccessful());
			
			// executed Done on the task, it is a completed task
			assertTrue(inMem.getTask(1).isCompleted());
			
			cmd = new CommandUndo();
			logic.executeCommand(cmd);
			assertTrue(logic.isSuccessful());
			
			// after undo, the completed task should be incomplete
			assertFalse(inMem.getTask(1).isCompleted());
			
		} catch (Exception e) {
			System.out.println("Command failed to execute.");
		}
	}

}

	// End of segment: C:\Users\Jerry\eclipse_workspace\CS2103Project\test\com\done\integration\LogicStorageTest.java





	/**
	 * origin: C:\Users\Jerry\eclipse_workspace\CS2103Project\test\com\done\model\DoneTest.java
	 */

package com.done.model;

import static org.junit.Assert.*;
import static org.hamcrest.CoreMatchers.*;

import org.junit.Test;

import com.done.model.Done.TaskType;

public class DoneTest {
	

	
	@Test
	public void testFloatingTask() {
		// assert that if is a new instance of DoneFloatingTask, then the
		// type is Floating Task
		Done done = new DoneFloatingTask("title1", "tag1");
		assertThat(done.getType(), is(TaskType.FLOATING));
	}

	@Test
	public void testTimedTask() {
		// assert that if is a new instance of DoneTimedTask, then the
		// type is Timed Task
		Done done = new DoneTimedTask("title1", 6711253, 6711253);
		assertThat(done.getType(), is(TaskType.TIMED));
	}

	@Test
	public void testDeadlineTask() {
		// assert that if is a new instance of DoneDeadlineTask, then the
		// type is Deadline Task
		Done done = new DoneDeadlineTask("title1", 676721);
		assertThat(done.getType(), is(TaskType.DEADLINE));
	}

	@Test
	public void testDoneString() {
		Done done = new DoneFloatingTask("test");
		assertThat(done.getTitle(), not("\\s"));
		assertThat(done.getTitle().length(), not(0));
	}

}

	// End of segment: C:\Users\Jerry\eclipse_workspace\CS2103Project\test\com\done\model\DoneTest.java





	/**
	 * origin: C:\Users\Jerry\eclipse_workspace\CS2103Project\test\com\done\storage\InMemStorageTest.java
	 */

package com.done.storage;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;

import java.util.ArrayList;
import java.util.List;

import org.joda.time.DateTime;
import org.junit.Before;
import org.junit.Test;

import com.done.model.Done;
import com.done.model.DoneDeadlineTask;
import com.done.model.DoneFloatingTask;
import com.done.model.DoneTimedTask;

public class InMemStorageTest {

	InMemStorage inMem = InMemStorage.getInstance();
	JsonStorage jsonStore = JsonStorage.getInstance(); 
	
	@Before
	public void setUp() {
		// use "testJson.json" file for testing
		jsonStore.setJsonNameToPref("tasks//testJson");
		// delete all tasks from memory and JSON first before performing tests
		inMem.delete(null, true);
	}

	@Test
	public void testStore() {
		Done doneFT = new DoneFloatingTask("test1");
		Done doneTT = new DoneTimedTask("test2", DateTime.now().getMillis(),
				DateTime.now().getMillis() + 88888);
		Done doneDT = new DoneDeadlineTask("test3",
				DateTime.now().getMillis() + 128000);
		// This is the equivalence partition for the Done ArrayList
		// whether is it [NULL] or [NOT NULL]
		assertNotNull(doneFT);
		assertNotNull(doneTT);
		assertTrue(inMem.store(doneFT));
		assertTrue(inMem.store(doneTT));
		assertTrue(inMem.store(doneDT));

	}

	@Test
	public void testStore2() {
		List<Done> testDone = new ArrayList<Done>();
		testDone.add(null);
		assertNull(testDone.get(0));
	}

	@Test
	public void testClear() {
		// add 3 items
		inMem.store(new DoneFloatingTask("test 1"));
		inMem.store(new DoneTimedTask("test2", DateTime.now().getMillis(),
				DateTime.now().getMillis() + 88888));
		inMem.store(new DoneDeadlineTask("test3",
				DateTime.now().getMillis() + 128000));
		assertTrue(inMem.getTasks().size() == 3);

		// boolean true in delete method states that it is clear
		inMem.delete(null, true);
		assertTrue(inMem.getTasks().size() == 0);

	}

	@Test
	public void testSetCompleted() {
		Done doneFT = new DoneFloatingTask("test1");

		// when first added, it is not a completed task
		inMem.store(doneFT);
		assertFalse(inMem.getTask(doneFT.getId()).isCompleted());

		// get and set to completed
		// should return true
		inMem.getTask(doneFT.getId()).setCompleted(true);
		assertTrue(inMem.getTask(doneFT.getId()).isCompleted());
	}

}

	// End of segment: C:\Users\Jerry\eclipse_workspace\CS2103Project\test\com\done\storage\InMemStorageTest.java





	/**
	 * origin: C:\Users\Jerry\eclipse_workspace\CS2103Project\test\com\done\storage\JsonStorageTest.java
	 */

package com.done.storage;

import static org.hamcrest.CoreMatchers.*;
import static org.junit.Assert.assertThat;
import static org.junit.Assert.assertTrue;

import java.io.FileNotFoundException;
import java.io.IOException;

import org.junit.Test;

public class JsonStorageTest {

	JsonStorage test = JsonStorage.getInstance();

	@Test
	public void testJsonNameToPrefs() throws FileNotFoundException, IOException {

		assertTrue(test.setJsonNameToPref("tasks//tasks"));

	}
	
	@Test
	public void testGetJsonName() {
		test.setJsonNameToPref("tasks//testJson");
		// if input to Properties is "testJson.json"
		// then the output after retrieving should be the same
		assertThat(test.getJsonNameFromPref(), is("tasks//testJson.json"));
	}

}

	// End of segment: C:\Users\Jerry\eclipse_workspace\CS2103Project\test\com\done\storage\JsonStorageTest.java





